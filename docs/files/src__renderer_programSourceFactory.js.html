<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/_renderer/programSourceFactory.js - xeogl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Billboard.html">Billboard</a></li>
                                <li><a href="../classes/Boundary2D.html">Boundary2D</a></li>
                                <li><a href="../classes/Boundary3D.html">Boundary3D</a></li>
                                <li><a href="../classes/BoundingSphereGeometry.html">BoundingSphereGeometry</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraController.html">CameraController</a></li>
                                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
                                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
                                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
                                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/CardboardEffect.html">CardboardEffect</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/ColorBuf.html">ColorBuf</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/Configs.html">Configs</a></li>
                                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Cull.html">Cull</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DepthBuf.html">DepthBuf</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
                                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/Layer.html">Layer</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/Modes.html">Modes</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/PointMarkings.html">PointMarkings</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
                                <li><a href="../classes/Shadow.html">Shadow</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
                                <li><a href="../classes/Stage.html">Stage</a></li>
                                <li><a href="../classes/Stationary.html">Stationary</a></li>
                                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/Visibility.html">Visibility</a></li>
                                <li><a href="../classes/xeogl.html">xeogl</a></li>
                                <li><a href="../classes/xeogl.math.math.html">xeogl.math.math</a></li>
                                <li><a href="../classes/ZSpaceEffect.html">ZSpaceEffect</a></li>
                                <li><a href="../classes/ZSpaceStylusControl.html">ZSpaceStylusControl</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/boundaries.html">boundaries</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/configs.html">configs</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/culling.html">culling</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/effects.html">effects</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/generation.html">generation</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/interaction.html">interaction</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/marking.html">marking</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/models.html">models</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/xeogl.html">xeogl</a></li>
                                <li><a href="..//modules/zspace.html">zspace</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/_renderer/programSourceFactory.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function () {

    &quot;use strict&quot;;

    /**
     *  Manages creation, sharing and recycle of {@link xeogl.renderer.ProgramSource} instances
     */
    xeogl.renderer.ProgramSourceFactory = new (function () {

        var cache = {}; // Caches source code against hashes

        var src = &quot;&quot;; // Accumulates source code as it&#x27;s being built

        var states; // Cache rendering state
        var phongMaterial;
        var MetallicMaterial;
        var SpecularMaterial;
        var texturing; // True when rendering state contains textures
        var normals; // True when rendering state contains normals
        var normalMapping; // True when rendering state contains tangents
        var reflection; // True when rendering state contains reflections
        var diffuseFresnel;
        var specularFresnel;
        var opacityFresnel;
        var reflectivityFresnel;
        var emissiveFresnel;
        var receiveShadow;

        var vertexPickObjectSrc;
        var fragmentPickObjectSrc;
        var vertexPickPrimSrc;
        var fragmentPickPrimSrc;
        var vertexShadowSrc;
        var fragmentShadowSrc;

        /**
         * Get source code for a program to render the given states.
         * Attempts to reuse cached source code for the given hash.
         */
        this.getSource = function (hash, _states) {

            var source = cache[hash];

            if (source) {
                source.useCount++;
                return source;
            }

            states = _states;

            texturing = hasTextures();
            normals = hasNormals();
            normalMapping = hasNormalMap();
            phongMaterial = (states.material.type === &quot;phongMaterial&quot;);
            MetallicMaterial = (states.material.type === &quot;MetallicMaterial&quot;);
            SpecularMaterial = (states.material.type === &quot;SpecularMaterial&quot;);
            reflection = hasReflection();
            diffuseFresnel = states.material.diffuseFresnel;
            specularFresnel = states.material.specularFresnel;
            opacityFresnel = states.material.opacityFresnel;
            reflectivityFresnel = states.material.reflectivityFresnel;
            emissiveFresnel = states.material.emissiveFresnel;
            receiveShadow = receivesShadow();

            source = new xeogl.renderer.ProgramSource(
                hash,
                vertexPickObject(),
                fragmentPickObject(),
                vertexPickPrimitive(),
                fragmentPickPrimitive(),
                vertexDraw(),
                fragmentDraw(),
                vertexShadow(),
                fragmentShadow()
            );

            cache[hash] = source;

            return source;
        };

        function receivesShadow() {
            if (!states.modes.receiveShadow) {
                return false;
            }
            var lights = states.lights.lights;
            if (!lights) {
                return false;
            }
            for (var i = 0, len = lights.length; i &lt; len; i++) {
                if (lights[i].shadow) {
                    return true;
                }
            }
            return false;
        }

        function hasTextures() {
            if (!states.geometry.uv) {
                return false;
            }
            var material = states.material;
            return material.ambientMap ||
                material.occlusionMap ||
                material.baseColorMap ||
                material.diffuseMap ||
                material.opacityMap ||
                material.specularMap ||
                material.glossinessMap ||
                material.specularGlossinessMap ||
                material.emissiveMap ||
                material.metallicMap ||
                material.roughnessMap ||
                material.metallicRoughnessMap ||
                material.reflectivityMap ||
                states.material.normalMap;
        }

        function hasReflection() {
            return false;
            //return (states.cubemap.layers &amp;&amp; states.cubemap.layers.length &gt; 0 &amp;&amp; states.geometry.normalBuf);
        }

        function hasNormals() {
            var primitive = states.geometry.primitiveName;
            if (states.geometry.normals &amp;&amp; (primitive === &quot;triangles&quot; || primitive === &quot;triangle-strip&quot; || primitive === &quot;triangle-fan&quot;)) {
                return true;
            }
            return false;
        }

        function hasNormalMap() {
            var geometry = states.geometry;
            return (geometry.positions &amp;&amp; geometry.indices &amp;&amp; geometry.normals &amp;&amp; geometry.uv &amp;&amp; states.material.normalMap);
        }

        /**
         * Releases program source code back to this factory.
         */
        this.putSource = function (hash) {
            var source = cache[hash];
            if (source) {
                if (--source.useCount === 0) {
                    cache[source.hash] = null;
                }
            }
        };


        // NOTE: Picking shaders will become more complex and will eventually be
        // composed from state, in the same manner as the draw shaders.

        function vertexPickObject() {
            if (vertexPickObjectSrc) {
                return vertexPickObjectSrc;
            }
            begin();
            add(&quot;// Object picking vertex shader&quot;);
            add(&quot;attribute vec3 xeo_aPosition;&quot;);
            add(&quot;uniform mat4 xeo_uModelMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uViewMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uViewNormalMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uProjMatrix;&quot;);
            add(&quot;varying vec4 xeo_vWorldPosition;&quot;);
            add(&quot;varying vec4 xeo_vViewPosition;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   vec4 tmpVertex = vec4(xeo_aPosition, 1.0); &quot;);
            add(&quot;   xeo_vWorldPosition = xeo_uModelMatrix * tmpVertex; &quot;);
            add(&quot;   xeo_vViewPosition = xeo_uViewMatrix * xeo_vWorldPosition;&quot;);
            add(&quot;   gl_Position = xeo_uProjMatrix * xeo_vViewPosition;&quot;);
            add(&quot;}&quot;);
            return vertexPickObjectSrc = end();
        }

        function fragmentPickObject() {
            if (fragmentPickObjectSrc) {
                return fragmentPickObjectSrc;
            }
            begin();
            add(&quot;// Object picking fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);
            add(&quot;uniform vec4 xeo_uPickColor;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   gl_FragColor = xeo_uPickColor; &quot;);
            add(&quot;}&quot;);
            return fragmentPickObjectSrc = end();
        }

        function vertexPickPrimitive() {

            if (vertexPickPrimSrc) {
                return vertexPickPrimSrc;
            }

            begin();

            add(&quot;// Triangle picking vertex shader&quot;);
            add(&quot;attribute vec3 xeo_aPosition;&quot;);
            add(&quot;attribute vec4 xeo_aColor;&quot;);

            add(&quot;uniform vec3 xeo_uPickColor;&quot;);
            add(&quot;uniform mat4 xeo_uModelMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uViewMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uProjMatrix;&quot;);

            add(&quot;varying vec4 xeo_vWorldPosition;&quot;);
            add(&quot;varying vec4 xeo_vViewPosition;&quot;);
            add(&quot;varying vec4 xeo_vColor;&quot;);

            add(&quot;void main(void) {&quot;);
            add(&quot;   vec4 tmpVertex = vec4(xeo_aPosition, 1.0); &quot;);
            add(&quot;   vec4 worldPosition = xeo_uModelMatrix * tmpVertex; &quot;);
            add(&quot;   vec4 viewPosition = xeo_uViewMatrix * worldPosition;&quot;);
            add(&quot;   xeo_vColor = xeo_aColor;&quot;);
            add(&quot;   gl_Position = xeo_uProjMatrix * viewPosition;&quot;);
            add(&quot;}&quot;);

            return vertexPickPrimSrc = end();
        }

        function fragmentPickPrimitive() {
            if (fragmentPickPrimSrc) {
                return fragmentPickPrimSrc;
            }
            begin();
            add(&quot;// Triangle picking fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);
            add(&quot;varying vec4 xeo_vColor;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   gl_FragColor = xeo_vColor;&quot;);
            add(&quot;}&quot;);
            return fragmentPickPrimSrc = end();
        }

        /// NOTE: Shadow shaders will become more complex and will eventually be
        // composed from state, in the same manner as the draw shaders.

        function vertexShadow() {
            begin();
            add(&quot;// Shadow map vertex shader&quot;);
            add(&quot;attribute vec3 xeo_aPosition;&quot;);
            add(&quot;uniform mat4 xeo_uModelMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uShadowViewMatrix;&quot;);
            add(&quot;uniform mat4 xeo_uShadowProjMatrix;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   gl_Position = xeo_uShadowProjMatrix * (xeo_uShadowViewMatrix * (xeo_uModelMatrix * (vec4(xeo_aPosition, 1.0))));&quot;);
            add(&quot;}&quot;);
            return vertexShadowSrc = end();
        }

        function fragmentShadow() {
            begin();
            add(&quot;// Shadow map fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);
            add(&quot;void main(void) {&quot;);
            add(&quot;   gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0);&quot;);
       //     add(&quot;   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);&quot;);
            add(&quot;}&quot;);
            return fragmentShadowSrc = end();
        }

        function vertexDraw() {

            var vertex = states.shader.vertex;

            if (vertex) { // Custom vertex shader
                return vertex;
            }

            var i;
            var len;
            var lights = states.lights.lights;
            var light;

            begin();

            add(&quot;// Drawing vertex shader&quot;);
            add(&quot;attribute  vec3 xeo_aPosition;&quot;);

            add(&quot;uniform    mat4 xeo_uModelMatrix;&quot;);
            add(&quot;uniform    mat4 xeo_uViewMatrix;&quot;);
            add(&quot;uniform    mat4 xeo_uProjMatrix;&quot;);

            add(&quot;varying    vec3 xeo_vViewPosition;&quot;);
            add(&quot;varying    vec3 xeo_vWorldPosition;&quot;);
            add(&quot;varying    vec3 xeo_vWorldNormal;&quot;);

            if (normals) {

                add(&quot;attribute  vec3 xeo_aNormal;&quot;);

                add(&quot;uniform    mat4 xeo_uModelNormalMatrix;&quot;);
                add(&quot;uniform    mat4 xeo_uViewNormalMatrix;&quot;);

                add(&quot;varying    vec3 xeo_vViewEyeVec;&quot;);
                add(&quot;varying    vec3 xeo_vViewNormal;&quot;);
                add(&quot;varying    mat3 xeo_TBN;&quot;);

                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) {

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    if (light.type === &quot;dir&quot;) {
                        add(&quot;uniform vec3 xeo_uLightDir&quot; + i + &quot;;&quot;);
                    }

                    if (light.type === &quot;point&quot;) {
                        add(&quot;uniform vec3 xeo_uLightPos&quot; + i + &quot;;&quot;);
                    }

                    if (light.type === &quot;spot&quot;) {
                        add(&quot;uniform vec3 xeo_uLightPos&quot; + i + &quot;;&quot;);
                    }

                    add(&quot;varying vec4 xeo_vViewLightReverseDirAndDist&quot; + i + &quot;;&quot;);
                }
            }

            if (normalMapping) {
                add(&quot;attribute vec3 xeo_aTangent;&quot;);
            }

            if (texturing) {
                add(&quot;attribute vec2 xeo_aUV;&quot;);
                add(&quot;varying vec2 xeo_vUV;&quot;);
            }

            if (states.geometry.colors) {
                add(&quot;attribute vec4 xeo_aColor;&quot;);
                add(&quot;varying vec4 xeo_vColor;&quot;);
            }

            if (states.geometry.primitiveName === &quot;points&quot;) {
                add(&quot;uniform float xeo_uPointSize;&quot;);
            }

            if (states.billboard.active) {

                add(&quot;void billboard(inout mat4 mat) {&quot;);
                add(&quot;   mat[0][0] = 1.0;&quot;);
                add(&quot;   mat[0][1] = 0.0;&quot;);
                add(&quot;   mat[0][2] = 0.0;&quot;);

                if (states.billboard.spherical) {
                    add(&quot;   mat[1][0] = 0.0;&quot;);
                    add(&quot;   mat[1][1] = 1.0;&quot;);
                    add(&quot;   mat[1][2] = 0.0;&quot;);
                }

                add(&quot;   mat[2][0] = 0.0;&quot;);
                add(&quot;   mat[2][1] = 0.0;&quot;);
                add(&quot;   mat[2][2] =1.0;&quot;);
                add(&quot;}&quot;);
            }

            if (receiveShadow) {
                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources
                    if (lights[i].shadow) {
                        add(&quot;uniform mat4 xeo_uShadowViewMatrix&quot; + i + &quot;;&quot;);
                        add(&quot;uniform mat4 xeo_uShadowProjMatrix&quot; + i + &quot;;&quot;);
                        add(&quot;varying vec4 xeo_vShadowPositionFromLight&quot; + i + &quot;;&quot;);
                    }
                }
            }

            add(&quot;void main(void) {&quot;);

            add(&quot;vec4 localPosition = vec4(xeo_aPosition, 1.0); &quot;);
            add(&quot;vec4 worldPosition;&quot;);

            if (normals) {
                add(&quot;vec4 localNormal = vec4(xeo_aNormal, 0.0); &quot;);
                add(&quot;mat4 modelNormalMatrix = xeo_uModelNormalMatrix;&quot;);
                add(&quot;mat4 viewNormalMatrix = xeo_uViewNormalMatrix;&quot;);
            }

            add(&quot;mat4 modelMatrix = xeo_uModelMatrix;&quot;);
            add(&quot;mat4 viewMatrix = xeo_uViewMatrix;&quot;);

            if (states.stationary.active) {
                add(&quot;viewMatrix[3][0] = viewMatrix[3][1] = viewMatrix[3][2] = 0.0;&quot;)
            }

            if (states.billboard.active) {

                add(&quot;mat4 modelViewMatrix = xeo_uViewMatrix * xeo_uModelMatrix;&quot;);

                add(&quot;billboard(modelMatrix);&quot;);
                add(&quot;billboard(viewMatrix);&quot;);
                add(&quot;billboard(modelViewMatrix);&quot;);

                if (normals) {
                    add(&quot;mat4 modelViewNormalMatrix =  xeo_uViewNormalMatrix * xeo_uModelNormalMatrix;&quot;);
                    add(&quot;billboard(modelNormalMatrix);&quot;);
                    add(&quot;billboard(viewNormalMatrix);&quot;);
                    add(&quot;billboard(modelViewNormalMatrix);&quot;);
                }

                add(&quot;worldPosition = modelMatrix * localPosition;&quot;);
                add(&quot;vec4 viewPosition = modelViewMatrix * localPosition;&quot;);

            } else {

                add(&quot;worldPosition = modelMatrix * localPosition;&quot;);
                add(&quot;vec4 viewPosition  = viewMatrix * worldPosition; &quot;);
            }

            if (normals) {

                add(&quot;vec3 worldNormal = (modelNormalMatrix * localNormal).xyz; &quot;);
                add(&quot;xeo_vWorldNormal = worldNormal;&quot;);
                add(&quot;xeo_vViewNormal = normalize((viewNormalMatrix * vec4(worldNormal, 1.0)).xyz);&quot;);

                if (normalMapping) {

                    add(&quot;mat4 mat =  viewMatrix * modelMatrix;&quot;);

                    add(&quot;vec3 n = normalize( ( mat * vec4( xeo_aNormal, 0.0 ) ).xyz );&quot;);
                    add(&quot;vec3 t = normalize( ( mat * vec4( xeo_aTangent, 0.0 ) ).xyz );&quot;);
                    add(&quot;vec3 b = normalize( ( mat * vec4( ( cross(xeo_aNormal, xeo_aTangent.xyz ) * 1.0 ), 0.0 ) ).xyz );&quot;);

                    add(&quot;xeo_TBN = mat3(t, b, n);&quot;);
                }

                add(&quot;vec3 tmpVec3;&quot;);
                add(&quot;float lightDist;&quot;);

                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) { // Lights

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    if (light.type === &quot;dir&quot;) {

                        if (light.space === &quot;world&quot;) {
                            add(&quot;tmpVec3 = vec3(viewMatrix * vec4(xeo_uLightDir&quot; + i + &quot;, 0.0) ).xyz;&quot;);
                        } else {
                            add(&quot;tmpVec3 = xeo_uLightDir&quot; + i + &quot;;&quot;);
                        }

                        add(&quot;xeo_vViewLightReverseDirAndDist&quot; + i + &quot; = vec4(-tmpVec3, 0.0);&quot;);
                    }

                    if (light.type === &quot;point&quot;) {

                        if (light.space === &quot;world&quot;) {
                            add(&quot;tmpVec3 = (viewMatrix * vec4(xeo_uLightPos&quot; + i + &quot;, 1.0)).xyz - viewPosition.xyz;&quot;);
                            add(&quot;lightDist = abs(length(tmpVec3));&quot;);

                        } else {
                            add(&quot;tmpVec3 = xeo_uLightPos&quot; + i + &quot;.xyz - viewPosition.xyz;&quot;);
                            add(&quot;lightDist = abs(length(tmpVec3));&quot;);
                        }

                        add(&quot;xeo_vViewLightReverseDirAndDist&quot; + i + &quot; = vec4(tmpVec3, lightDist);&quot;);
                    }
                }

                add(&quot;xeo_vViewEyeVec = -viewPosition.xyz;&quot;);
            }

            if (texturing) {
                add(&quot;xeo_vUV = xeo_aUV;&quot;);
            }

            if (states.geometry.colors) {
                add(&quot;xeo_vColor = xeo_aColor;&quot;);
            }

            if (states.geometry.primitiveName === &quot;points&quot;) {
                add(&quot;gl_PointSize = xeo_uPointSize;&quot;);
            }
            add(&quot;   xeo_vViewPosition = viewPosition.xyz;&quot;);
            add(&quot;   gl_Position = xeo_uProjMatrix * viewPosition;&quot;);

            if (receiveShadow) {
                add(&quot;vec4 tempx; &quot;);
                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources
                    if (lights[i].shadow) {
                        add(&quot;xeo_vShadowPositionFromLight&quot; + i + &quot; = xeo_uShadowProjMatrix&quot; + i + &quot; * (xeo_uShadowViewMatrix&quot; + i + &quot; * worldPosition); &quot;);
                        //add(&quot;tempx = xeo_uShadowViewMatrix&quot; + i + &quot; * worldPosition; &quot;);
                        //add(&quot;tempx = xeo_uShadowProjMatrix&quot; + i + &quot; * tempx; &quot;);
                        //add(&quot;   gl_Position = tempx;&quot;);
                    }
                }
            }

            add(&quot;}&quot;);

            return end();
        }

        function fragmentDraw() {

            var material = states.material;
            var geometry = states.geometry;

            var phongMaterial = material.type === &quot;phongMaterial&quot;;
            var pbrMetalRough = material.type === &quot;MetallicMaterial&quot;;
            var pbrSpecGloss = material.type === &quot;SpecularMaterial&quot;;

            var i;
            var len;
            var lights = states.lights.lights;
            var light;

            begin();

            add(&quot;// Drawing fragment shader&quot;);

            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);

            //--------------------------------------------------------------------------------
            // LIGHT AND REFLECTION MAP INPUTS
            // Define here so available globally to shader functions
            //--------------------------------------------------------------------------------

            if (states.lights.lightMap) {
                add(&quot;uniform samplerCube xeo_uLightMap;&quot;);
                add(&quot;uniform    mat4 xeo_uViewNormalMatrix;&quot;);
            }

            if (states.lights.reflectionMap) {
                add(&quot;uniform samplerCube xeo_uReflectionMap;&quot;);
            }

            if (states.lights.lightMap || states.lights.reflectionMap) {
                add(&quot;uniform mat4 xeo_uViewMatrix;&quot;);
            }


            //--------------------------------------------------------------------------------
            // SHADING FUNCTIONS
            //--------------------------------------------------------------------------------

            // CONSTANT DEFINITIONS

            add(&quot;#define PI 3.14159265359&quot;);
            add(&quot;#define RECIPROCAL_PI 0.31830988618&quot;);
            add(&quot;#define RECIPROCAL_PI2 0.15915494&quot;);
            add(&quot;#define EPSILON 1e-6&quot;);

            add(&quot;#define saturate(a) clamp( a, 0.0, 1.0 )&quot;);

            // UTILITY DEFINITIONS

            add(&quot;float pow2(const in float x) {&quot;);
            add(&quot;   return x*x;&quot;);
            add(&quot;}&quot;);

            add(&quot;vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {&quot;);
            add(&quot;   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );&quot;);
            add(&quot;}&quot;);

            // STRUCTURES

            add(&quot;struct IncidentLight {&quot;);
            add(&quot;   vec3 color;&quot;);
            add(&quot;   vec3 direction;&quot;);
            add(&quot;};&quot;);

            add(&quot;struct ReflectedLight {&quot;);
            add(&quot;   vec3 diffuse;&quot;);
            add(&quot;   vec3 specular;&quot;);
            add(&quot;};&quot;);

            add(&quot;struct Geometry {&quot;);
            add(&quot;   vec3 position;&quot;);
            add(&quot;   vec3 viewNormal;&quot;);
            add(&quot;   vec3 worldNormal;&quot;);
            add(&quot;   vec3 viewEyeDir;&quot;);
            add(&quot;};&quot;);

            add(&quot;struct Material {&quot;);
            add(&quot;   vec3    diffuseColor;&quot;);
            add(&quot;   float   specularRoughness;&quot;);
            add(&quot;   vec3    specularColor;&quot;);
            add(&quot;   float   shine;&quot;); // Only used for Phong
            add(&quot;};&quot;);

            // DIFFUSE BRDF EVALUATION

            add(&quot;vec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor) {&quot;);
            add(&quot;   return RECIPROCAL_PI * diffuseColor;&quot;);
            add(&quot;}&quot;);

            // COMMON UTILS

            add(&quot;vec4 LinearTosRGB( in vec4 value ) {&quot;);
            add(&quot;   return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055), value.rgb*12.92, vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.w);&quot;);
            add(&quot;}&quot;);

            if (phongMaterial) {

                if (states.lights.lightMap || states.lights.reflectionMap) {

                    add(&quot;void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);

                    if (states.lights.lightMap) {
                        add(&quot;   vec3 irradiance = textureCube(xeo_uLightMap, geometry.worldNormal).rgb;&quot;);
                        add(&quot;   irradiance *= PI;&quot;);
                        add(&quot;   vec3 diffuseBRDFContrib = BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                        add(&quot;   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;&quot;);
                    }

                    if (states.lights.reflectionMap) {
                        //     add(&quot;   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.worldNormal);&quot;);
                        //   //  add(&quot;   reflectVec                  = inverseTransformDirection(reflectVec, xeo_uViewMatrix);&quot;);
                        //     add(&quot;   vec3 radiance               = textureCube(xeo_uReflectionMap, geometry.worldNormal).rgb;&quot;);
                        ////     add(&quot;   radiance *= PI;&quot;);
                        //     add(&quot;   reflectedLight.specular     += radiance;&quot;);
                    }

                    add(&quot;}&quot;);
                }

                add(&quot;void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);
                add(&quot;   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));&quot;);
                add(&quot;   vec3 irradiance = dotNL * directLight.color * PI;&quot;);
                add(&quot;   reflectedLight.diffuse  += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                add(&quot;   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);&quot;);
                add(&quot;}&quot;);
            }

            if (pbrMetalRough || pbrSpecGloss) {

                // IRRADIANCE EVALUATION

                //add(&quot;vec3 sample_reflectMapEquirect(const in vec3 reflect, const in float mipLevel) {&quot;);
                //add(&quot;   vec2 sampleUV;&quot;);
                //add(&quot;   sampleUV.y = saturate(reflect.y * 0.5 + 0.5);&quot;);
                //add(&quot;   sampleUV.x = atan(reflect.z, reflect.x) * RECIPROCAL_PI2 + 0.5;&quot;);
                //add(&quot;   vec4 texColor = texture2D(xeo_uReflectionMap, sampleUV, mipLevel);&quot;);
                //add(&quot;   return texColor.rgb;&quot;); // assumed to be linear
                //add(&quot;}&quot;);

                add(&quot;float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {&quot;);
                add(&quot;   return (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);&quot;);
                add(&quot;}&quot;);

                add(&quot;float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {&quot;);
                add(&quot;   float maxMIPLevelScalar = float( maxMIPLevel );&quot;);
                add(&quot;   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );&quot;);
                add(&quot;   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );&quot;);
                add(&quot;}&quot;);

                //add(&quot;vec3 getLightProbeIndirectRadiance(const in mat4 viewMatrix, const in Geometry geometry, const in float blinnShininessExponent, const in int maxMIPLevel) {&quot;);
                //add(&quot;   vec3 reflectVec = reflect(geometry.viewEyeDir, geometry.viewNormal);&quot;);
                //add(&quot;   reflectVec = inverseTransformDirection(reflectVec, viewMatrix);&quot;);
                //add(&quot;   float mipLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );&quot;);
                //add(&quot;   vec3 reflectionMapColor = sample_reflectMapEquirect(reflectVec, float(mipLevel));&quot;);
                //add(&quot;   return reflectionMapColor;&quot;);
                //add(&quot;}&quot;);


                if (states.lights.reflectionMap) {
                    add(&quot;vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {&quot;);
                    add(&quot;   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);&quot;); //TODO: a random factor - fix this
                    add(&quot;   vec3 envMapColor = textureCube(xeo_uReflectionMap, reflectVec, mipLevel).rgb;&quot;);
                    add(&quot;   return envMapColor;&quot;);
                    add(&quot;}&quot;);
                }

                // SPECULAR BRDF EVALUATION

                add(&quot;vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {&quot;);
                add(&quot;   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );&quot;);
                add(&quot;   return ( 1.0 - specularColor ) * fresnel + specularColor;&quot;);
                add(&quot;}&quot;);

                add(&quot;float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {&quot;);
                add(&quot;   float a2 = pow2( alpha );&quot;);
                add(&quot;   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );&quot;);
                add(&quot;   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );&quot;);
                add(&quot;   return 1.0 / ( gl * gv );&quot;);
                add(&quot;}&quot;);

                add(&quot;float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {&quot;);
                add(&quot;   float a2 = pow2( alpha );&quot;);
                add(&quot;   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );&quot;);
                add(&quot;   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );&quot;);
                add(&quot;   return 0.5 / max( gv + gl, EPSILON );&quot;);
                add(&quot;}&quot;);

                add(&quot;float D_GGX(const in float alpha, const in float dotNH) {&quot;);
                add(&quot;   float a2 = pow2( alpha );&quot;);
                add(&quot;   float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;&quot;);
                add(&quot;   return RECIPROCAL_PI * a2 / pow2( denom );&quot;);
                add(&quot;}&quot;);

                add(&quot;vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {&quot;);
                add(&quot;   float alpha = pow2( roughness );&quot;);
                add(&quot;   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );&quot;);
                add(&quot;   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );&quot;);
                add(&quot;   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );&quot;);
                add(&quot;   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );&quot;);
                add(&quot;   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );&quot;);
                add(&quot;   vec3  F = F_Schlick( specularColor, dotLH );&quot;);
                add(&quot;   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );&quot;);
                add(&quot;   float D = D_GGX( alpha, dotNH );&quot;);
                add(&quot;   return F * (G * D);&quot;);
                add(&quot;}&quot;);

                add(&quot;vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {&quot;);
                add(&quot;   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));&quot;);
                add(&quot;   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);&quot;);
                add(&quot;   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);&quot;);
                add(&quot;   vec4 r = roughness * c0 + c1;&quot;);
                add(&quot;   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;&quot;);
                add(&quot;   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;&quot;);
                add(&quot;   return specularColor * AB.x + AB.y;&quot;);
                add(&quot;}&quot;);


                if (states.lights.lightMap || states.lights.reflectionMap) {

                    add(&quot;void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);

                    if (states.lights.lightMap) {
                        add(&quot;   vec3 irradiance = textureCube(xeo_uLightMap, geometry.worldNormal).rgb;&quot;);
                        add(&quot;   irradiance *= PI;&quot;);
                        add(&quot;   vec3 diffuseBRDFContrib = BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                        add(&quot;   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;&quot;);
                        //   add(&quot;   reflectedLight.diffuse = vec3(1.0, 0.0, 0.0);&quot;);
                    }

                    if (states.lights.reflectionMap) {
                        add(&quot;   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);&quot;);
                        add(&quot;   reflectVec                  = inverseTransformDirection(reflectVec, xeo_uViewMatrix);&quot;);
                        add(&quot;   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);&quot;);
                        add(&quot;   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);&quot;);
                        add(&quot;   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);&quot;);
                        add(&quot;   reflectedLight.specular     += radiance * specularBRDFContrib;&quot;);
                    }

                    add(&quot;}&quot;);
                }

                // MAIN LIGHTING COMPUTATION FUNCTION

                add(&quot;void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);
                add(&quot;   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));&quot;);
                add(&quot;   vec3 irradiance = dotNL * incidentLight.color * PI;&quot;);
                add(&quot;   reflectedLight.diffuse  += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                add(&quot;   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);&quot;);
                add(&quot;}&quot;);
            }

            //--------------------------------------------------------------------------------
            // GEOMETRY INPUTS
            //--------------------------------------------------------------------------------

            add(&quot;varying vec3 xeo_vViewPosition;&quot;);
            add(&quot;varying vec3 xeo_vWorldPosition;&quot;);

            if (geometry.colors) {
                add(&quot;varying vec4 xeo_vColor;&quot;);
            }

            if (geometry.uv &amp;&amp; ((geometry.normals &amp;&amp; material.normalMap)
                || material.ambientMap
                || material.baseColorMap
                || material.diffuseMap
                || material.emissiveMap
                || material.metallicMap
                || material.roughnessMap
                || material.metallicRoughnessMap
                || material.specularMap
                || material.glossinessMap
                || material.specularGlossinessMap
                || material.occlusionMap
                || material.opacityMap)) {
                add(&quot;varying vec2 xeo_vUV;&quot;);
            }

            if (geometry.normals) {
                add(&quot;varying vec3 xeo_vWorldNormal;&quot;);
                add(&quot;varying vec3 xeo_vViewNormal;&quot;);
            }

            //--------------------------------------------------------------------------------
            // MATERIAL CHANNEL INPUTS
            //--------------------------------------------------------------------------------

            if (material.ambient) {
                add(&quot;uniform vec3 xeo_uAmbient;&quot;);
            }

            if (material.baseColor) {
                add(&quot;uniform vec3 xeo_uBaseColor;&quot;);
            }

            if (material.opacity !== undefined &amp;&amp; material.opacity !== null) {
                add(&quot;uniform float xeo_uOpacity;&quot;);
            }

            if (material.emissive) {
                add(&quot;uniform vec3 xeo_uEmissive;&quot;);
            }

            if (material.diffuse) {
                add(&quot;uniform vec3 xeo_uDiffuse;&quot;);
            }

            if (material.glossiness !== undefined &amp;&amp; material.glossiness !== null) {
                add(&quot;uniform float xeo_uGlossiness;&quot;);
            }

            if (material.shininess !== undefined &amp;&amp; material.shininess !== null) {
                add(&quot;uniform float xeo_uShininess;&quot;);  // Phong channel
            }

            if (material.specular) {
                add(&quot;uniform vec3 xeo_uSpecular;&quot;);
            }

            if (material.metallic !== undefined &amp;&amp; material.metallic !== null) {
                add(&quot;uniform float xeo_uMetallic;&quot;);
            }

            if (material.roughness !== undefined &amp;&amp; material.roughness !== null) {
                add(&quot;uniform float xeo_uRoughness;&quot;);
            }

            if (material.specularF0 !== undefined &amp;&amp; material.specularF0 !== null) {
                add(&quot;uniform float xeo_uSpecularF0;&quot;);
            }

            //--------------------------------------------------------------------------------
            // MATERIAL TEXTURE INPUTS
            //--------------------------------------------------------------------------------

            if (geometry.uv &amp;&amp; material.ambientMap) {
                add(&quot;uniform sampler2D xeo_uAmbientMap;&quot;);
                if (material.ambientMap.matrix) {
                    add(&quot;uniform mat4 xeo_uAmbientMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.baseColorMap) {
                add(&quot;uniform sampler2D xeo_uBaseColorMap;&quot;);
                if (material.baseColorMap.matrix) {
                    add(&quot;uniform mat4 xeo_uBaseColorMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.diffuseMap) {
                add(&quot;uniform sampler2D xeo_uDiffuseMap;&quot;);
                if (material.diffuseMap.matrix) {
                    add(&quot;uniform mat4 xeo_uDiffuseMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.emissiveMap) {
                add(&quot;uniform sampler2D xeo_uEmissiveMap;&quot;);
                if (material.emissiveMap.matrix) {
                    add(&quot;uniform mat4 xeo_uEmissiveMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.metallicMap) {
                add(&quot;uniform sampler2D xeo_uMetallicMap;&quot;);
                if (material.metallicMap.matrix) {
                    add(&quot;uniform mat4 xeo_uMetallicMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.roughnessMap) {
                add(&quot;uniform sampler2D xeo_uRoughnessMap;&quot;);
                if (material.roughnessMap.matrix) {
                    add(&quot;uniform mat4 xeo_uRoughnessMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.metallicRoughnessMap) {
                add(&quot;uniform sampler2D xeo_uMetallicRoughnessMap;&quot;);
                if (material.metallicRoughnessMap.matrix) {
                    add(&quot;uniform mat4 xeo_uMetallicRoughnessMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; material.normalMap) {
                add(&quot;varying mat3 xeo_TBN;&quot;);
                add(&quot;uniform sampler2D xeo_uNormalMap;&quot;);
                if (material.normalMap.matrix) {
                    add(&quot;uniform mat4 xeo_uNormalMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.occlusionMap) {
                add(&quot;uniform sampler2D xeo_uOcclusionMap;&quot;);
                if (material.occlusionMap.matrix) {
                    add(&quot;uniform mat4 xeo_uOcclusionMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.opacityMap) {
                add(&quot;uniform sampler2D xeo_uOpacityMap;&quot;);
                if (material.opacityMap.matrix) {
                    add(&quot;uniform mat4 xeo_uOpacityMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.specularMap) {
                add(&quot;uniform sampler2D xeo_uSpecularMap;&quot;);
                if (material.specularMap.matrix) {
                    add(&quot;uniform mat4 xeo_uSpecularMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.glossinessMap) {
                add(&quot;uniform sampler2D xeo_uGlossinessMap;&quot;);
                if (material.glossinessMap.matrix) {
                    add(&quot;uniform mat4 xeo_uGlossinessMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.specularGlossinessMap) {
                add(&quot;uniform sampler2D xeo_uSpecularGlossinessMap;&quot;);
                if (material.specularGlossinessMap.matrix) {
                    add(&quot;uniform mat4 xeo_uSpecularGlossinessMapMatrix;&quot;);
                }
            }

            //--------------------------------------------------------------------------------
            // MATERIAL FRESNEL INPUTS
            //--------------------------------------------------------------------------------

            if (geometry.normals &amp;&amp; (material.diffuseFresnel ||
                material.specularFresnel ||
                material.opacityFresnel ||
                material.emissiveFresnel ||
                material.reflectivityFresnel)) {

                add(&quot;float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {&quot;);
                add(&quot;    float fr = abs(dot(eyeDir, normal));&quot;);
                add(&quot;    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);&quot;);
                add(&quot;    return pow(finalFr, power);&quot;);
                add(&quot;}&quot;);

                if (material.diffuseFresnel) {
                    add(&quot;uniform float  xeo_uDiffuseFresnelCenterBias;&quot;);
                    add(&quot;uniform float  xeo_uDiffuseFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  xeo_uDiffuseFresnelPower;&quot;);
                    add(&quot;uniform vec3   xeo_uDiffuseFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   xeo_uDiffuseFresnelEdgeColor;&quot;);
                }

                if (material.specularFresnel) {
                    add(&quot;uniform float  xeo_uSpecularFresnelCenterBias;&quot;);
                    add(&quot;uniform float  xeo_uSpecularFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  xeo_uSpecularFresnelPower;&quot;);
                    add(&quot;uniform vec3   xeo_uSpecularFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   xeo_uSpecularFresnelEdgeColor;&quot;);
                }

                if (material.opacityFresnel) {
                    add(&quot;uniform float  xeo_uOpacityFresnelCenterBias;&quot;);
                    add(&quot;uniform float  xeo_uOpacityFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  xeo_uOpacityFresnelPower;&quot;);
                    add(&quot;uniform vec3   xeo_uOpacityFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   xeo_uOpacityFresnelEdgeColor;&quot;);
                }

                if (material.reflectivityFresnel) {
                    add(&quot;uniform float  xeo_uSpecularF0FresnelCenterBias;&quot;);
                    add(&quot;uniform float  xeo_uSpecularF0FresnelEdgeBias;&quot;);
                    add(&quot;uniform float  xeo_uSpecularF0FresnelPower;&quot;);
                    add(&quot;uniform vec3   xeo_uSpecularF0FresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   xeo_uSpecularF0FresnelEdgeColor;&quot;);
                }

                if (material.emissiveFresnel) {
                    add(&quot;uniform float  xeo_uEmissiveFresnelCenterBias;&quot;);
                    add(&quot;uniform float  xeo_uEmissiveFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  xeo_uEmissiveFresnelPower;&quot;);
                    add(&quot;uniform vec3   xeo_uEmissiveFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   xeo_uEmissiveFresnelEdgeColor;&quot;);
                }
            }

            //--------------------------------------------------------------------------------
            // LIGHT SOURCES
            //--------------------------------------------------------------------------------

            add(&quot;uniform vec3   xeo_uLightAmbientColor;&quot;);
            add(&quot;uniform float  xeo_uLightAmbientIntensity;&quot;);

            if (geometry.normals) {

                add(&quot;varying vec3 xeo_vViewEyeVec;&quot;);

                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources

                    light = lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    add(&quot;uniform vec3 xeo_uLightColor&quot; + i + &quot;;&quot;);
                    add(&quot;uniform float xeo_uLightIntensity&quot; + i + &quot;;&quot;);

                    if (light.type === &quot;point&quot;) {
                        add(&quot;uniform vec3 xeo_uLightAttenuation&quot; + i + &quot;;&quot;);
                    }

                    add(&quot;varying vec4 xeo_vViewLightReverseDirAndDist&quot; + i + &quot;;&quot;); // Vector from light to vertex
                }
            }

            //--------------------------------------------------------------------------------
            // SHADOWS
            //--------------------------------------------------------------------------------

            if (receiveShadow) {
                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources
                    if (lights[i].shadow) {
                        add(&quot;varying vec4 xeo_vShadowPositionFromLight&quot; + i + &quot;;&quot;);
                        add(&quot;uniform sampler2D xeo_uShadowMap&quot; + i + &quot;;&quot;);
                    }
                }
            }

            //================================================================================
            // MAIN
            //================================================================================

            add(&quot;void main(void) {&quot;);

            if (geometry.primitiveName === &quot;points&quot;) {
                add(&quot;vec2 cxy = 2.0 * gl_PointCoord - 1.0;&quot;);
                add(&quot;float r = dot(cxy, cxy);&quot;);
                add(&quot;if (r &gt; 1.0) {&quot;);
                add(&quot;   discard;&quot;);
                add(&quot;}&quot;);
            }

            add(&quot;float occlusion = 1.0;&quot;);

            if (material.ambient) {
                add(&quot;vec3 ambient = xeo_uAmbient;&quot;);
            } else {
                add(&quot;vec3 ambient = vec3(1.0, 1.0, 1.0);&quot;);
            }

            if (material.diffuse) {
                add(&quot;vec3 diffuse = xeo_uDiffuse;&quot;);
            } else if (material.baseColor) {
                add(&quot;vec3 diffuse = xeo_uBaseColor;&quot;);
            } else {
                add(&quot;vec3 diffuse = vec3(1.0, 1.0, 1.0);&quot;);
            }

            if (material.emissive) {
                add(&quot;vec3 emissive = xeo_uEmissive;&quot;); // Emissive default is (0,0,0), so initializing here
            } else {
                add(&quot;vec3  emissive = vec3(0.0, 0.0, 0.0);&quot;);
            }

            if (material.specular) {
                add(&quot;vec3 specular = xeo_uSpecular;&quot;);
            } else {
                add(&quot;vec3 specular = vec3(1.0, 1.0, 1.0);&quot;);
            }

            if (material.opacity !== undefined) {
                add(&quot;float opacity = xeo_uOpacity;&quot;);
            } else {
                add(&quot;float opacity = 1.0;&quot;);
            }

            if (material.glossiness !== undefined) {
                add(&quot;float glossiness = xeo_uGlossiness;&quot;);
            } else {
                add(&quot;float glossiness = 1.0;&quot;);
            }

            if (material.metallic !== undefined) {
                add(&quot;float metallic = xeo_uMetallic;&quot;);
            } else {
                add(&quot;float metallic = 1.0;&quot;);
            }

            if (material.roughness !== undefined) {
                add(&quot;float roughness = xeo_uRoughness;&quot;);
            } else {
                add(&quot;float roughness = 1.0;&quot;);
            }

            if (material.specularF0 !== undefined) {
                add(&quot;float specularF0 = xeo_uSpecularF0;&quot;);
            } else {
                add(&quot;float specularF0 = 1.0;&quot;);
            }

            //--------------------------------------------------------------------------------
            // TEXTURING
            //--------------------------------------------------------------------------------

            if (geometry.uv
                &amp;&amp; ((geometry.normals &amp;&amp; material.normalMap)
                || material.ambientMap
                || material.baseColorMap
                || material.diffuseMap
                || material.occlusionMap
                || material.emissiveMap
                || material.metallicMap
                || material.roughnessMap
                || material.metallicRoughnessMap
                || material.specularMap
                || material.glossinessMap
                || material.specularGlossinessMap
                || material.opacityMap)) {
                add(&quot;vec4 texturePos = vec4(xeo_vUV.s, xeo_vUV.t, 1.0, 1.0);&quot;);
                add(&quot;vec2 textureCoord;&quot;);
            }

            if (geometry.uv &amp;&amp; material.ambientMap) {
                if (material.ambientMap.matrix) {
                    add(&quot;textureCoord = (xeo_uAmbientMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;ambient *= texture2D(xeo_uAmbientMap, textureCoord).rgb;&quot;);
            }

            if (geometry.uv &amp;&amp; material.diffuseMap) {
                if (material.diffuseMap.matrix) {
                    add(&quot;textureCoord = (xeo_uDiffuseMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;diffuse *= texture2D(xeo_uDiffuseMap, textureCoord).rgb;&quot;);
            }

            if (geometry.uv &amp;&amp; material.baseColorMap) {
                if (material.baseColorMap.matrix) {
                    add(&quot;textureCoord = (xeo_uBaseColorMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;diffuse *= texture2D(xeo_uBaseColorMap, textureCoord).rgb;&quot;);
            }

            if (geometry.uv &amp;&amp; material.emissiveMap) {
                if (material.emissiveMap.matrix) {
                    add(&quot;textureCoord = (xeo_uEmissiveMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;emissive *= texture2D(xeo_uEmissiveMap, textureCoord).rgb;&quot;);
            }

            if (geometry.uv &amp;&amp; material.opacityMap) {
                if (material.opacityMap.matrix) {
                    add(&quot;textureCoord = (xeo_uOpacityMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;opacity *= texture2D(xeo_uOpacityMap, textureCoord).r;&quot;);
            }

            if (geometry.uv &amp;&amp; material.occlusionMap) {
                if (material.occlusionMap.matrix) {
                    add(&quot;textureCoord = (xeo_uOcclusionMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;occlusion *= texture2D(xeo_uOcclusionMap, textureCoord).r;&quot;);
            }

            if (geometry.normals &amp;&amp; ((lights.length &gt; 0) || states.lights.lightMap || states.lights.reflectionMap)) {

                //--------------------------------------------------------------------------------
                // SHADING
                //--------------------------------------------------------------------------------

                if (material.normalMap) {
                    if (material.normalMap.matrix) {
                        add(&quot;textureCoord = (xeo_uNormalMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;vec3 viewNormal = xeo_TBN * normalize( texture2D(xeo_uNormalMap, vec2(textureCoord.x, textureCoord.y) ).rgb * 2.0 - 1.0);&quot;);
                } else {
                    add(&quot;vec3 viewNormal = normalize(xeo_vViewNormal);&quot;);
                }

                if (geometry.uv &amp;&amp; material.specularMap) {
                    if (material.specularMap.matrix) {
                        add(&quot;textureCoord = (xeo_uSpecularMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;specular *= texture2D(xeo_uSpecularMap, textureCoord).rgb;&quot;);
                }

                if (geometry.uv &amp;&amp; material.glossinessMap) {
                    if (material.glossinessMap.matrix) {
                        add(&quot;textureCoord = (xeo_uGlossinessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;glossiness *= texture2D(xeo_uGlossinessMap, textureCoord).r;&quot;);
                }

                if (geometry.uv &amp;&amp; material.specularGlossinessMap) {
                    if (material.specularGlossinessMap.matrix) {
                        add(&quot;textureCoord = (xeo_uSpecularGlossinessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;vec4 specGlossRGB = texture2D(xeo_uSpecularGlossinessMap, textureCoord).rgba;&quot;); // TODO: what if only RGB texture?
                    add(&quot;specular *= specGlossRGB.rgb;&quot;);
                    add(&quot;glossiness *= specGlossRGB.a;&quot;);
                }

                if (geometry.uv &amp;&amp; material.metallicMap) {
                    if (material.metallicMap.matrix) {
                        add(&quot;textureCoord = (xeo_uMetallicMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;metallic *= texture2D(xeo_uMetallicMap, textureCoord).r;&quot;);
                }

                if (geometry.uv &amp;&amp; material.roughnessMap) {
                    if (material.roughnessMap.matrix) {
                        add(&quot;textureCoord = (xeo_uRoughnessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;roughness *= texture2D(xeo_uRoughnessMap, textureCoord).r;&quot;);
                }

                if (geometry.uv &amp;&amp; material.metallicRoughnessMap) {
                    if (material.metallicRoughnessMap.matrix) {
                        add(&quot;textureCoord = (xeo_uMetallicRoughnessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;vec3 metalRoughRGB = texture2D(xeo_uMetallicRoughnessMap, textureCoord).rgb;&quot;);
                    add(&quot;metallic *= metalRoughRGB.r;&quot;);
                    add(&quot;roughness *= metalRoughRGB.g;&quot;);
                }

                add(&quot;vec3 viewEyeDir = normalize(-xeo_vViewPosition);&quot;);

                if (material.diffuseFresnel || material.specularFresnel || material.opacityFresnel || material.emissiveFresnel || material.reflectivityFresnel) {
                    if (material.diffuseFresnel) {
                        add(&quot;float diffuseFresnel = fresnel(viewEyeDir, viewNormal, xeo_uDiffuseFresnelEdgeBias, xeo_uDiffuseFresnelCenterBias, xeo_uDiffuseFresnelPower);&quot;);
                        add(&quot;diffuse *= mix(xeo_uDiffuseFresnelEdgeColor, xeo_uDiffuseFresnelCenterColor, diffuseFresnel);&quot;);
                    }
                    if (material.specularFresnel) {
                        add(&quot;float specularFresnel = fresnel(viewEyeDir, viewNormal, xeo_uSpecularFresnelEdgeBias, xeo_uSpecularFresnelCenterBias, xeo_uSpecularFresnelPower);&quot;);
                        add(&quot;specular *= mix(xeo_uSpecularFresnelEdgeColor, xeo_uSpecularFresnelCenterColor, specularFresnel);&quot;);
                    }
                    if (material.opacityFresnel) {
                        add(&quot;float opacityFresnel = fresnel(viewEyeDir, viewNormal, xeo_uOpacityFresnelEdgeBias, xeo_uOpacityFresnelCenterBias, xeo_uOpacityFresnelPower);&quot;);
                        add(&quot;opacity *= mix(xeo_uOpacityFresnelEdgeColor.r, xeo_uOpacityFresnelCenterColor.r, opacityFresnel);&quot;);
                    }
                    if (material.emissiveFresnel) {
                        add(&quot;float emissiveFresnel = fresnel(viewEyeDir, viewNormal, xeo_uEmissiveFresnelEdgeBias, xeo_uEmissiveFresnelCenterBias, xeo_uEmissiveFresnelPower);&quot;);
                        add(&quot;emissive *= mix(xeo_uEmissiveFresnelEdgeColor, xeo_uEmissiveFresnelCenterColor, emissiveFresnel);&quot;);
                    }
                }

                // PREPARE INPUTS FOR SHADER FUNCTIONS

                add(&quot;IncidentLight  light;&quot;);
                add(&quot;Material       material;&quot;);
                add(&quot;Geometry       geometry;&quot;);
                add(&quot;ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));&quot;);
                add(&quot;vec3           viewLightDir;&quot;);

                if (phongMaterial) {
                    add(&quot;material.diffuseColor      = diffuse;&quot;);
                    add(&quot;material.specularColor     = specular;&quot;);
                    add(&quot;material.shine             = xeo_uShininess;&quot;);
                }

                if (pbrSpecGloss) {
                    add(&quot;float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);&quot;); // Energy conservation
                    add(&quot;material.diffuseColor      = diffuse * oneMinusSpecularStrength;&quot;);
                    add(&quot;material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );&quot;);
                    add(&quot;material.specularColor     = specular;&quot;);
                }

                if (pbrMetalRough) {
                    add(&quot;float dielectricSpecular = 0.16 * specularF0 * specularF0;&quot;);
                    add(&quot;material.diffuseColor      = diffuse * (1.0 - dielectricSpecular) * (1.0 - metallic);&quot;);
                    add(&quot;material.specularRoughness = clamp(roughness, 0.04, 1.0);&quot;);
                    add(&quot;material.specularColor     = mix(vec3(dielectricSpecular), diffuse, metallic);&quot;);
                }

                add(&quot;geometry.position      = xeo_vViewPosition;&quot;);
                if (states.lights.lightMap) {
                    add(&quot;geometry.worldNormal   = normalize(xeo_vWorldNormal);&quot;);
                }
                add(&quot;geometry.viewNormal    = viewNormal;&quot;);
                add(&quot;geometry.viewEyeDir    = viewEyeDir;&quot;);

                // ENVIRONMENT AND REFLECTION MAP SHADING

                if ((phongMaterial) &amp;&amp; (states.lights.lightMap || states.lights.reflectionMap)) {
                    add(&quot;computePhongLightMapping(geometry, material, reflectedLight);&quot;);
                }

                if ((pbrSpecGloss || pbrMetalRough) &amp;&amp; (states.lights.lightMap || states.lights.reflectionMap)) {
                    add(&quot;computePBRLightMapping(geometry, material, reflectedLight);&quot;);
                }

                // LIGHT SOURCE SHADING

                var light;

                for (i = 0, len = lights.length; i &lt; len; i++) {

                    light = lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    add(&quot;viewLightDir = normalize(xeo_vViewLightReverseDirAndDist&quot; + i + &quot;.xyz);&quot;); // If normal mapping, the fragment-&gt;light vector will be in tangent space

                    add(&quot;light.direction = viewLightDir;&quot;);
                    add(&quot;light.color = xeo_uLightIntensity&quot; + i + &quot; * xeo_uLightColor&quot; + i + &quot;;&quot;);

                    if (phongMaterial) {
                        add(&quot;computePhongLighting(light, geometry, material, reflectedLight);&quot;);
                    }

                    if (pbrSpecGloss || pbrMetalRough) {
                        add(&quot;computePBRLighting(light, geometry, material, reflectedLight);&quot;);
                    }
                }

                //--------------------------------------------------------------------------------
                // Shadow mapping
                //--------------------------------------------------------------------------------

                add(&quot;float shadow = 1.0;&quot;);

                if (receiveShadow) {

                    add(&quot;vec3 shadowCoord;&quot;);
                    add(&quot;float depth;&quot;);
                    add(&quot;vec4 rgbaDepth;&quot;);

                    for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources

                        light = lights[i];

                        if (light.shadow) {
                            add(&quot;shadowCoord = (xeo_vShadowPositionFromLight&quot; + i + &quot;.xyz / xeo_vShadowPositionFromLight&quot; + i + &quot;.w) / 2.0 - 1.0;&quot;);
                            add(&quot;rgbaDepth = texture2D(xeo_uShadowMap&quot; + i + &quot;, shadowCoord.xy);&quot;);
                            add(&quot;depth = rgbaDepth.r;&quot;);
                            add(&quot;shadow *= (shadowCoord.z &gt; depth + 0.005) ? 0.7 : 1.0;&quot;);
                            //add(&quot;shadow *= (shadowCoord.z == 0.0) ? 0.2 : 1.0;&quot;);
                        }
                    }
                }

                // COMBINE TERMS

                if (phongMaterial) {

                    add(&quot;ambient *= xeo_uLightAmbientColor;&quot;);

                    add(&quot;vec3 outgoingLight =  (shadow * occlusion * (ambient + reflectedLight.diffuse + reflectedLight.specular)) + emissive;&quot;);

                } else {
                    add(&quot;vec3 outgoingLight = (shadow * occlusion * reflectedLight.diffuse) + (shadow * occlusion * reflectedLight.specular) + emissive;&quot;);
                }

            } else {

                //--------------------------------------------------------------------------------
                // NO SHADING - EMISSIVE ONLY
                //--------------------------------------------------------------------------------

                add(&quot;vec3 outgoingLight = emissive;&quot;);
            }


            add(&quot;gl_FragColor = vec4(outgoingLight, opacity);&quot;);
           //     add(&quot;gl_FragColor = LinearTosRGB(gl_FragColor);&quot;);  // Gamma correction

            add(&quot;}&quot;);

            return end();
        }

        // Start fresh program source
        function begin() {
            src = [];
        }

        // Append to program source
        function add(txt) {
            src.push(txt || &quot;&quot;);
        }

        // Finish building program source
        function end() {
            return src;
        }

        function getFSFloatPrecision(gl) {

            if (!gl.getShaderPrecisionFormat) {
                return &quot;mediump&quot;;
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision &gt; 0) {
                return &quot;highp&quot;;
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision &gt; 0) {
                return &quot;mediump&quot;;
            }

            return &quot;lowp&quot;;
        }

    })
    ();

})
();
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
