<!DOCTYPE html>
<html lang="en">
<head>
    <title>xeogl Example</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <script src="../build/xeogl.js"></script>
    <link href="css/styles.css" rel="stylesheet"/>

<body>

<div id="info">
    <h1><a href="../docs/classes/Entity.html" target="_parent">Entity</a> with a custom metallic PBR <a
            href="../docs/classes/Shader.html" target="_parent">Shader</a></h1>
    <br>

    <div id="log" style="max-width: 800px;">this custom shader is physically-based, rendering <a
            href="../docs/classes/MetallicMaterial.html" target="_parent">MetallicMaterial</a> with Cook-Torrance and
        Lambertian specular and diffuse BRDFs, GGX microfacet distribution, and Schlick's Approximation for Fresnel
        term.
    </div>
</div>

<script>

    var entity = new xeogl.Entity({

        // Torus-shaped mesh

        geometry: new xeogl.TorusGeometry(),

        // Metal-roughness material with baseColor texture

        material: new xeogl.MetallicMaterial({
            type: "xeogl.MetallicMaterial",
            baseColor: [0.8, 0.8, 1.0],
            metallic: 1.0,
            roughness: 0.6,
            baseColorMap: {
                src: "textures/diffuse/uvGrid2.jpg"
            }
        }),

        // Three View-space directional lights

        lights: new xeogl.Lights({
            lights: [
                new xeogl.DirLight({
                    dir: [0.8, -0.6, -0.8],
                    color: [1.0, 0.7, 0.7],
                    intensity: 1.0,
                    space: "view"
                }),
                new xeogl.DirLight({
                    dir: [-0.8, -0.4, -0.4],
                    color: [0.7, 1.0, 0.7],
                    intensity: 1.0,
                    space: "view"
                }),
                new xeogl.DirLight({
                    dir: [0.2, -0.8, 0.8],
                    color: [0.6, 0.6, 0.6],
                    intensity: 1.0,
                    space: "view"
                })
            ]
        }),

        // Ordinarily xeogl generates shaders for us, but to this Entity we'll
        // attach our own custom Cook-Torrance/Lambertian/GGX/Schlick PBR shader.

        // The Shader is coded to take input from the various components
        // attached to this Entity, which include our TorusGeometry, MetallicMaterial and
        // DirLights, as well as the Scene's default Camera and Transform components, which
        // are implicitly attached to this Entity.

        // Note the comments beside the attributes and uniforms, indicating the
        // entity component/property they get their values from.

        shader: new xeogl.Shader({

            vertex: [

                "attribute vec3 position;",         // entity.geometry.positions
                "attribute vec3 normal;",           // entity.geometry.normals
                "attribute vec2 uv;",               // entity.geometry.uv

                "uniform mat4 modelMatrix;",        // entity.transform.matrix
                "uniform mat4 modelNormalMatrix;",  // entity.transform.normalMatrix
                "uniform mat4 viewMatrix;",         // entity.camera.view.matrix
                "uniform mat4 viewNormalMatrix;",   // entity.camera.view.normalMatrix
                "uniform mat4 projMatrix;",         // entity.camera.proj.matrix

                "uniform vec3 lightDir0;",          // entity.lights.lights[0].dir
                "uniform vec3 lightDir1;",          // entity.lights.lights[1].dir
                "uniform vec3 lightDir2;",          // entity.lights.lights[2].dir

                "varying vec3 vViewPosition;",
                "varying vec4 vViewLightReverseDirAndDist0;",
                "varying vec3 vViewNormal;",
                "varying vec4 vViewLightReverseDirAndDist1;",
                "varying vec4 vViewLightReverseDirAndDist2;",
                "varying vec2 vUV;",

                "void main(void) {",

                "   vec4 localPosition = vec4(position, 1.0); ",
                "   vec4 worldPosition;",
                "   vec4 localNormal = vec4(normal, 0.0); ",
                "   worldPosition = modelMatrix * localPosition;",
                "   vec4 viewPosition  = viewMatrix * worldPosition; ",
                "   vec3 worldNormal = (modelNormalMatrix * localNormal).xyz; ",

                "   vViewLightReverseDirAndDist0 = vec4(-lightDir0, 0.0);",
                "   vViewLightReverseDirAndDist1 = vec4(-lightDir1, 0.0);",
                "   vViewLightReverseDirAndDist2 = vec4(-lightDir2, 0.0);",
                "   vViewNormal = normalize((viewNormalMatrix * vec4(worldNormal, 1.0)).xyz);",
                "   vUV = uv;",
                "   vViewPosition = viewPosition.xyz;",

                "   gl_Position = projMatrix * viewPosition;",
                "}"
            ],

            fragment: [

                "precision highp float;",

                "#define            PI 3.14159265359",
                "#define            RECIPROCAL_PI 0.31830988618",
                "#define            RECIPROCAL_PI2 0.15915494",
                "#define            EPSILON 1e-6",
                "#define            saturate(a) clamp( a, 0.0, 1.0 )",

                "uniform vec3       materialBaseColor;",    // entity.material.baseColor
                "uniform float      materialOpacity;",      // entity.material.opacity
                "uniform vec3       materialEmissive;",     // entity.material.emissive
                "uniform float      materialMetallic;",     // entity.material.metallic
                "uniform float      materialRoughness;",    // entity.material.roughness
                "uniform float      materialSpecularF0;",   // entity.material.specularF0
                "uniform sampler2D  baseColorMap;",         // entity.material.baseColor
                "uniform vec3       lightAmbient;",         // [0,0,0]
                "uniform float      lightAmbientIntensity;",// 1
                "uniform vec3       lightColor0;",          // entity.lights.lights[0].color
                "uniform float      lightIntensity0;",      // entity.lights.lights[0].intensity
                "uniform vec3       lightColor1;",          // entity.lights.lights[1].color
                "uniform float      lightIntensity1;",      // entity.lights.lights[1].intensity
                "uniform vec3       lightColor2;",          // entity.lights.lights[2].color
                "uniform float      lightIntensity2;",      // entity.lights.lights[2].intensity

                "varying vec3       vViewPosition;",
                "varying vec2       vUV;",
                "varying vec3       vViewNormal;",
                "varying vec4       vViewLightReverseDirAndDist0;",
                "varying vec4       vViewLightReverseDirAndDist1;",
                "varying vec4       vViewLightReverseDirAndDist2;",

                "float pow2(const in float x) {",
                "   return x*x;",
                "}",

                "vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {",
                "   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );",
                "}",

                "struct IncidentLight {",
                "   vec3 color;",
                "   vec3 direction;",
                "};",

                "struct ReflectedLight {",
                "   vec3 diffuse;",
                "   vec3 specular;",
                "};",

                "struct Geometry {",
                "   vec3 position;",
                "   vec3 viewNormal;",
                "   vec3 worldNormal;",
                "   vec3 viewEyeDir;",
                "};",

                "struct Material {",
                "   vec3    diffuseColor;",
                "   float   specularRoughness;",
                "   vec3    specularColor;",
                "   float   shine;",
                "};",

                "vec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor) {",
                "   return RECIPROCAL_PI * diffuseColor;",
                "}",

                "vec4 LinearTosRGB( in vec4 value ) {",
                "   return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055), value.rgb*12.92, vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.w);",
                "}",

                "float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {",
                "   return (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);",
                "}",

                "float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {",
                "   float maxMIPLevelScalar = float( maxMIPLevel );",
                "   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );",
                "   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );",
                "}",

                "vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {",
                "   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );",
                "   return ( 1.0 - specularColor ) * fresnel + specularColor;",
                "}",

                "float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {",
                "   float a2 = pow2( alpha );",
                "   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );",
                "   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );",
                "   return 1.0 / ( gl * gv );",
                "}",

                "float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {",
                "   float a2 = pow2( alpha );",
                "   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );",
                "   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );",
                "   return 0.5 / max( gv + gl, EPSILON );",
                "}",

                "float D_GGX(const in float alpha, const in float dotNH) {",
                "   float a2 = pow2( alpha );",
                "   float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;",
                "   return RECIPROCAL_PI * a2 / pow2( denom );",
                "}",

                "vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {",
                "   float alpha = pow2( roughness );",
                "   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );",
                "   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );",
                "   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );",
                "   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );",
                "   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );",
                "   vec3  F = F_Schlick( specularColor, dotLH );",
                "   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );",
                "   float D = D_GGX( alpha, dotNH );",
                "   return F * (G * D);",
                "}",

                "vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {",
                "   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));",
                "   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);",
                "   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);",
                "   vec4 r = roughness * c0 + c1;",
                "   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;",
                "   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;",
                "   return specularColor * AB.x + AB.y;",
                "}",

                "void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {",
                "   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));",
                "   vec3 irradiance = dotNL * incidentLight.color * PI;",
                "   reflectedLight.diffuse  += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);",
                "   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);",
                "}",


                "void main(void) {",

                "   float   occlusion = 1.0;",
                "   vec3    ambientColor = vec3(1.0, 1.0, 1.0);",
                "   vec3    baseColor = materialBaseColor;",
                "   vec3    emissive = materialEmissive;",
                "   vec3    specular = vec3(1.0, 1.0, 1.0);",
                "   float   opacity = materialOpacity;",
                "   float   glossiness = 1.0;",
                "   float   metallic = materialMetallic;",
                "   float   roughness = materialRoughness;",
                "   float   specularF0 = materialSpecularF0;",

                "   vec4    texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);",
                "   vec2    textureCoord;",

                "   textureCoord = texturePos.xy;",
                "   baseColor *= texture2D(baseColorMap, vUV).rgb;",

                "   vec3 viewNormal = normalize(vViewNormal);",
                "   vec3 viewEyeDir = normalize(-vViewPosition);",

                "   IncidentLight  light;",
                "   Material       material;",
                "   Geometry       geometry;",
                "   ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));",

                "   float dielectricSpecular = 0.16 * specularF0 * specularF0;",

                "   material.diffuse      = baseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);",
                "   material.specularRoughness = clamp(roughness, 0.04, 1.0);",
                "   material.specularColor     = mix(vec3(dielectricSpecular), baseColor, metallic);",

                "   geometry.position      = vViewPosition;",
                "   geometry.viewNormal    = viewNormal;",
                "   geometry.viewEyeDir    = viewEyeDir;",

                "   light.direction        = normalize(vViewLightReverseDirAndDist0.xyz);",
                "   light.color            = lightIntensity0 * lightColor0;",
                "   computePBRLighting(light, geometry, material, reflectedLight);",

                "   light.direction        = normalize(vViewLightReverseDirAndDist1.xyz);",
                "   light.color            = lightIntensity1 * lightColor1;",
                "   computePBRLighting(light, geometry, material, reflectedLight);",

                "   light.direction        = normalize(vViewLightReverseDirAndDist2.xyz);",
                "   light.color            = lightIntensity2 * lightColor2;",
                "   computePBRLighting(light, geometry, material, reflectedLight);",

                "   vec3 outgoingLight     = (occlusion * reflectedLight.diffuse) + (occlusion * reflectedLight.specular) + emissive;",

                "   gl_FragColor = vec4(outgoingLight, opacity);",
                "}"
            ]
        })
    });

    entity.camera.view.zoom(-5);

    entity.scene.on("tick", function () {
        var view = entity.scene.camera.view;
        view.rotateEyeY(0.2);
        view.rotateEyeX(0.1);
    });

    new xeogl.CameraControl();

    //console.log(JSON.stringify(entity.glsl, null, "\t"))

</script>
</body>
</html>